# Sidebar Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a file tree sidebar with workspace mounting, file watching, and quick open (Cmd+P) functionality.

**Architecture:** `WorkspaceManager` handles mounting/unmounting. `SidebarController` manages the `NSOutlineView` for the file tree. `FileWatcher` uses FSEvents for efficient directory monitoring. All components implement `WorkspaceProviding` protocol from scaffolding.

**Tech Stack:** Swift 5.9+, AppKit (NSOutlineView, NSSplitView), FSEvents API

---

## Prerequisites

- Scaffolding must be complete (provides `WorkspaceProviding` protocol, `FileTreeNode` type)
- No dependencies on other modules — sidebar works independently

---

## What You're Building

A sidebar that:
1. Shows a file tree for a mounted workspace directory
2. Watches for external file changes (FSEvents)
3. Supports quick open (Cmd+P) to fuzzy-find files
4. Integrates with document opening (via callback)

---

## Project Structure (additions to scaffolding)

```
Sources/MarkdownEditor/
├── Workspace/
│   ├── WorkspaceManager.swift        ← Workspace state management
│   ├── FileWatcher.swift             ← FSEvents integration
│   ├── SidebarController.swift       ← NSOutlineView management
│   └── QuickOpenController.swift     ← Cmd+P panel
└── Tests/
    └── MarkdownEditorTests/
        └── Workspace/
            ├── WorkspaceManagerTests.swift
            └── FileWatcherTests.swift
```

---

## Task 1: WorkspaceManager

**Files:**
- Create: `Sources/MarkdownEditor/Workspace/WorkspaceManager.swift`
- Create: `Tests/MarkdownEditorTests/Workspace/WorkspaceManagerTests.swift`

**Step 1: Write failing test**

```swift
import XCTest
@testable import MarkdownEditor

final class WorkspaceManagerTests: XCTestCase {

    var tempDir: URL!

    override func setUp() {
        super.setUp()
        tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("workspace-test-\(UUID().uuidString)")
        try? FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
    }

    override func tearDown() {
        try? FileManager.default.removeItem(at: tempDir)
        super.tearDown()
    }

    func testMountWorkspace() throws {
        let manager = WorkspaceManager()
        XCTAssertNil(manager.workspaceRoot)

        try manager.mountWorkspace(at: tempDir)
        XCTAssertEqual(manager.workspaceRoot, tempDir)
    }

    func testUnmountWorkspace() throws {
        let manager = WorkspaceManager()
        try manager.mountWorkspace(at: tempDir)

        manager.unmountWorkspace()
        XCTAssertNil(manager.workspaceRoot)
    }

    func testFileTreeEnumeration() throws {
        // Create test files
        let subdir = tempDir.appendingPathComponent("subdir")
        try FileManager.default.createDirectory(at: subdir, withIntermediateDirectories: true)
        try "test".write(to: tempDir.appendingPathComponent("file1.md"), atomically: true, encoding: .utf8)
        try "test".write(to: subdir.appendingPathComponent("file2.md"), atomically: true, encoding: .utf8)

        let manager = WorkspaceManager()
        try manager.mountWorkspace(at: tempDir)

        guard let tree = manager.fileTree() else {
            XCTFail("Expected file tree")
            return
        }

        XCTAssertEqual(tree.url, tempDir)
        XCTAssertTrue(tree.isDirectory)
        XCTAssertNotNil(tree.children)
        XCTAssertEqual(tree.children?.count, 2)  // file1.md and subdir
    }
}
```

**Step 2: Run test to verify it fails**

Run: `swift test --filter WorkspaceManagerTests`
Expected: FAIL

**Step 3: Create WorkspaceManager**

```swift
import Foundation

/// Manages the currently mounted workspace.
///
/// A workspace is a directory containing files the user is working with.
/// Only one workspace can be mounted at a time.
final class WorkspaceManager: WorkspaceProviding {

    /// Currently mounted workspace root.
    private(set) var workspaceRoot: URL?

    /// Cached file tree (rebuilt on mount and file changes).
    private var cachedTree: FileTreeNode?

    /// Callback when file changes externally.
    var onFileChanged: ((URL) -> Void)?

    /// File watcher for the workspace.
    private var fileWatcher: FileWatcher?

    // MARK: - WorkspaceProviding

    func mountWorkspace(at url: URL) throws {
        // Validate it's a directory
        var isDirectory: ObjCBool = false
        guard FileManager.default.fileExists(atPath: url.path, isDirectory: &isDirectory),
              isDirectory.boolValue else {
            throw WorkspaceError.notADirectory
        }

        // Unmount previous workspace
        unmountWorkspace()

        workspaceRoot = url
        cachedTree = nil

        // Start watching
        fileWatcher = FileWatcher()
        fileWatcher?.onFileChanged = { [weak self] changedURL in
            self?.handleFileChange(changedURL)
        }
        fileWatcher?.watchWorkspace(at: url)
    }

    func unmountWorkspace() {
        fileWatcher?.stopWatchingWorkspace()
        fileWatcher = nil
        workspaceRoot = nil
        cachedTree = nil
    }

    func fileTree() -> FileTreeNode? {
        guard let root = workspaceRoot else { return nil }

        if let cached = cachedTree {
            return cached
        }

        cachedTree = buildFileTree(at: root)
        return cachedTree
    }

    func searchFiles(matching pattern: String) -> [URL] {
        guard let root = workspaceRoot else { return [] }

        var matches: [URL] = []
        let lowercasePattern = pattern.lowercased()

        enumerateFiles(in: root) { url in
            if url.lastPathComponent.lowercased().contains(lowercasePattern) {
                matches.append(url)
            }
        }

        return matches.sorted { $0.lastPathComponent < $1.lastPathComponent }
    }

    // MARK: - Private

    private func buildFileTree(at url: URL) -> FileTreeNode {
        let isDirectory = (try? url.resourceValues(forKeys: [.isDirectoryKey]))?.isDirectory ?? false

        var children: [FileTreeNode]?

        if isDirectory {
            let contents = (try? FileManager.default.contentsOfDirectory(
                at: url,
                includingPropertiesForKeys: [.isDirectoryKey],
                options: [.skipsHiddenFiles]
            )) ?? []

            children = contents
                .sorted { $0.lastPathComponent < $1.lastPathComponent }
                .map { buildFileTree(at: $0) }
        }

        return FileTreeNode(url: url, isDirectory: isDirectory, children: children)
    }

    private func enumerateFiles(in directory: URL, handler: (URL) -> Void) {
        guard let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isDirectoryKey],
            options: [.skipsHiddenFiles]
        ) else { return }

        for case let fileURL as URL in enumerator {
            let isDirectory = (try? fileURL.resourceValues(forKeys: [.isDirectoryKey]))?.isDirectory ?? false
            if !isDirectory {
                handler(fileURL)
            }
        }
    }

    private func handleFileChange(_ url: URL) {
        // Invalidate cache
        cachedTree = nil
        onFileChanged?(url)
    }
}

enum WorkspaceError: LocalizedError {
    case notADirectory

    var errorDescription: String? {
        switch self {
        case .notADirectory:
            return "The specified path is not a directory."
        }
    }
}
```

**Step 4: Run tests**

Run: `swift test --filter WorkspaceManagerTests`
Expected: Tests may fail due to missing FileWatcher — that's expected

**Step 5: Commit**

```bash
git add Sources/MarkdownEditor/Workspace/WorkspaceManager.swift
git add Tests/MarkdownEditorTests/Workspace/WorkspaceManagerTests.swift
git commit -m "feat(sidebar): add WorkspaceManager for workspace mounting"
```

---

## Task 2: FileWatcher with FSEvents

**Files:**
- Create: `Sources/MarkdownEditor/Workspace/FileWatcher.swift`
- Create: `Tests/MarkdownEditorTests/Workspace/FileWatcherTests.swift`

**Step 1: Create FileWatcher**

```swift
import Foundation

/// Watches a directory tree for file changes using FSEvents.
///
/// FSEvents is efficient for large directories — monitors the entire
/// tree with a single system resource.
final class FileWatcher {

    /// Callbacks for file system events.
    var onFileChanged: ((URL) -> Void)?
    var onFileDeleted: ((URL) -> Void)?
    var onFileCreated: ((URL) -> Void)?

    /// FSEvent stream for workspace watching.
    private var eventStream: FSEventStreamRef?

    /// Root directory being watched.
    private var watchedRoot: URL?

    // MARK: - Workspace Watching

    func watchWorkspace(at root: URL) {
        stopWatchingWorkspace()

        watchedRoot = root

        var context = FSEventStreamContext(
            version: 0,
            info: Unmanaged.passUnretained(self).toOpaque(),
            retain: nil,
            release: nil,
            copyDescription: nil
        )

        let callback: FSEventStreamCallback = { (
            streamRef,
            clientCallBackInfo,
            numEvents,
            eventPaths,
            eventFlags,
            eventIds
        ) in
            guard let clientCallBackInfo = clientCallBackInfo else { return }
            let watcher = Unmanaged<FileWatcher>.fromOpaque(clientCallBackInfo).takeUnretainedValue()

            let paths = unsafeBitCast(eventPaths, to: NSArray.self)

            for i in 0..<numEvents {
                guard let pathString = paths[i] as? String else { continue }
                let url = URL(fileURLWithPath: pathString)
                let flags = eventFlags[i]

                DispatchQueue.main.async {
                    if flags & UInt32(kFSEventStreamEventFlagItemRemoved) != 0 {
                        watcher.onFileDeleted?(url)
                    } else if flags & UInt32(kFSEventStreamEventFlagItemCreated) != 0 {
                        watcher.onFileCreated?(url)
                    } else if flags & UInt32(kFSEventStreamEventFlagItemModified) != 0 {
                        watcher.onFileChanged?(url)
                    } else {
                        // Generic change
                        watcher.onFileChanged?(url)
                    }
                }
            }
        }

        let pathsToWatch = [root.path] as CFArray

        eventStream = FSEventStreamCreate(
            kCFAllocatorDefault,
            callback,
            &context,
            pathsToWatch,
            FSEventStreamEventId(kFSEventStreamEventIdSinceNow),
            0.5,  // Latency in seconds
            FSEventStreamCreateFlags(kFSEventStreamCreateFlagFileEvents | kFSEventStreamCreateFlagUseCFTypes)
        )

        if let stream = eventStream {
            FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetMain(), CFRunLoopMode.defaultMode.rawValue)
            FSEventStreamStart(stream)
        }
    }

    func stopWatchingWorkspace() {
        if let stream = eventStream {
            FSEventStreamStop(stream)
            FSEventStreamInvalidate(stream)
            FSEventStreamRelease(stream)
            eventStream = nil
        }
        watchedRoot = nil
    }

    deinit {
        stopWatchingWorkspace()
    }
}
```

**Step 2: Add basic test**

```swift
import XCTest
@testable import MarkdownEditor

final class FileWatcherTests: XCTestCase {

    func testWatcherCanBeCreated() {
        let watcher = FileWatcher()
        XCTAssertNotNil(watcher)
    }

    func testWatcherCanStartAndStop() {
        let watcher = FileWatcher()
        let tempDir = FileManager.default.temporaryDirectory

        watcher.watchWorkspace(at: tempDir)
        watcher.stopWatchingWorkspace()

        // Should not crash
        XCTAssertTrue(true)
    }
}
```

**Step 3: Run tests**

Run: `swift test --filter FileWatcherTests`
Expected: Tests pass

**Step 4: Commit**

```bash
git add Sources/MarkdownEditor/Workspace/FileWatcher.swift
git add Tests/MarkdownEditorTests/Workspace/FileWatcherTests.swift
git commit -m "feat(sidebar): add FileWatcher with FSEvents for directory monitoring"
```

---

## Task 3: SidebarController with NSOutlineView

**Files:**
- Create: `Sources/MarkdownEditor/Workspace/SidebarController.swift`

**Step 1: Create SidebarController**

```swift
import AppKit

/// Controller for the file tree sidebar.
///
/// Uses `NSOutlineView` to display the workspace file structure.
/// Handles user interaction for opening files.
final class SidebarController: NSViewController {

    /// Workspace manager providing file tree data.
    var workspaceManager: WorkspaceManager? {
        didSet {
            outlineView?.reloadData()
        }
    }

    /// Callback when user selects a file to open.
    var onFileSelected: ((URL) -> Void)?

    /// The outline view displaying the file tree.
    private var outlineView: NSOutlineView!

    /// Scroll view containing the outline view.
    private var scrollView: NSScrollView!

    // MARK: - Lifecycle

    override func loadView() {
        view = NSView()
        view.translatesAutoresizingMaskIntoConstraints = false
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        setupOutlineView()
    }

    private func setupOutlineView() {
        // Create scroll view
        scrollView = NSScrollView()
        scrollView.translatesAutoresizingMaskIntoConstraints = false
        scrollView.hasVerticalScroller = true
        scrollView.hasHorizontalScroller = false
        scrollView.autohidesScrollers = true
        scrollView.borderType = .noBorder
        view.addSubview(scrollView)

        // Create outline view
        outlineView = NSOutlineView()
        outlineView.headerView = nil
        outlineView.rowHeight = 24
        outlineView.indentationPerLevel = 16
        outlineView.autoresizesOutlineColumn = true

        // Add column
        let column = NSTableColumn(identifier: NSUserInterfaceItemIdentifier("FileColumn"))
        column.title = "Files"
        column.minWidth = 100
        outlineView.addTableColumn(column)
        outlineView.outlineTableColumn = column

        // Wire up data source and delegate
        outlineView.dataSource = self
        outlineView.delegate = self

        // Enable double-click to open
        outlineView.target = self
        outlineView.doubleAction = #selector(handleDoubleClick(_:))

        scrollView.documentView = outlineView

        // Constraints
        NSLayoutConstraint.activate([
            scrollView.topAnchor.constraint(equalTo: view.topAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }

    // MARK: - Actions

    @objc private func handleDoubleClick(_ sender: Any?) {
        let row = outlineView.clickedRow
        guard row >= 0,
              let node = outlineView.item(atRow: row) as? FileTreeNode,
              !node.isDirectory else { return }

        onFileSelected?(node.url)
    }

    // MARK: - Refresh

    func refresh() {
        outlineView?.reloadData()
    }
}

// MARK: - NSOutlineViewDataSource

extension SidebarController: NSOutlineViewDataSource {

    func outlineView(_ outlineView: NSOutlineView, numberOfChildrenOfItem item: Any?) -> Int {
        if item == nil {
            // Root level
            return workspaceManager?.fileTree()?.children?.count ?? 0
        }

        if let node = item as? FileTreeNode {
            return node.children?.count ?? 0
        }

        return 0
    }

    func outlineView(_ outlineView: NSOutlineView, child index: Int, ofItem item: Any?) -> Any {
        if item == nil {
            // Root level
            return workspaceManager?.fileTree()?.children?[index] ?? FileTreeNode(url: URL(fileURLWithPath: "/"), isDirectory: false, children: nil)
        }

        if let node = item as? FileTreeNode {
            return node.children?[index] ?? FileTreeNode(url: URL(fileURLWithPath: "/"), isDirectory: false, children: nil)
        }

        return FileTreeNode(url: URL(fileURLWithPath: "/"), isDirectory: false, children: nil)
    }

    func outlineView(_ outlineView: NSOutlineView, isItemExpandable item: Any) -> Bool {
        if let node = item as? FileTreeNode {
            return node.isDirectory && (node.children?.isEmpty == false)
        }
        return false
    }
}

// MARK: - NSOutlineViewDelegate

extension SidebarController: NSOutlineViewDelegate {

    func outlineView(_ outlineView: NSOutlineView, viewFor tableColumn: NSTableColumn?, item: Any) -> NSView? {
        guard let node = item as? FileTreeNode else { return nil }

        let cellIdentifier = NSUserInterfaceItemIdentifier("FileCell")
        var cell = outlineView.makeView(withIdentifier: cellIdentifier, owner: self) as? NSTableCellView

        if cell == nil {
            cell = NSTableCellView()
            cell?.identifier = cellIdentifier

            let imageView = NSImageView()
            imageView.translatesAutoresizingMaskIntoConstraints = false
            cell?.addSubview(imageView)
            cell?.imageView = imageView

            let textField = NSTextField(labelWithString: "")
            textField.translatesAutoresizingMaskIntoConstraints = false
            textField.lineBreakMode = .byTruncatingTail
            cell?.addSubview(textField)
            cell?.textField = textField

            NSLayoutConstraint.activate([
                imageView.leadingAnchor.constraint(equalTo: cell!.leadingAnchor, constant: 2),
                imageView.centerYAnchor.constraint(equalTo: cell!.centerYAnchor),
                imageView.widthAnchor.constraint(equalToConstant: 16),
                imageView.heightAnchor.constraint(equalToConstant: 16),

                textField.leadingAnchor.constraint(equalTo: imageView.trailingAnchor, constant: 4),
                textField.trailingAnchor.constraint(equalTo: cell!.trailingAnchor, constant: -2),
                textField.centerYAnchor.constraint(equalTo: cell!.centerYAnchor)
            ])
        }

        cell?.textField?.stringValue = node.name
        cell?.imageView?.image = NSWorkspace.shared.icon(forFile: node.url.path)

        return cell
    }
}
```

**Step 2: Commit**

```bash
git add Sources/MarkdownEditor/Workspace/SidebarController.swift
git commit -m "feat(sidebar): add SidebarController with NSOutlineView file tree"
```

---

## Task 4: QuickOpenController (Cmd+P)

**Files:**
- Create: `Sources/MarkdownEditor/Workspace/QuickOpenController.swift`

**Step 1: Create QuickOpenController**

```swift
import AppKit

/// Controller for the quick open panel (Cmd+P).
///
/// Shows a search field and filtered list of files.
final class QuickOpenController: NSWindowController {

    /// Workspace manager for file search.
    var workspaceManager: WorkspaceManager?

    /// Callback when user selects a file.
    var onFileSelected: ((URL) -> Void)?

    private var searchField: NSSearchField!
    private var tableView: NSTableView!
    private var scrollView: NSScrollView!
    private var searchResults: [URL] = []

    init() {
        let window = NSPanel(
            contentRect: NSRect(x: 0, y: 0, width: 500, height: 300),
            styleMask: [.titled, .closable, .resizable],
            backing: .buffered,
            defer: false
        )
        window.title = "Quick Open"
        window.isFloatingPanel = true
        window.becomesKeyOnlyIfNeeded = false
        window.level = .floating
        window.center()

        super.init(window: window)

        setupUI()
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) not implemented")
    }

    private func setupUI() {
        guard let contentView = window?.contentView else { return }

        // Search field
        searchField = NSSearchField()
        searchField.translatesAutoresizingMaskIntoConstraints = false
        searchField.placeholderString = "Search files..."
        searchField.target = self
        searchField.action = #selector(searchFieldChanged(_:))
        contentView.addSubview(searchField)

        // Scroll view with table
        scrollView = NSScrollView()
        scrollView.translatesAutoresizingMaskIntoConstraints = false
        scrollView.hasVerticalScroller = true
        scrollView.borderType = .bezelBorder
        contentView.addSubview(scrollView)

        tableView = NSTableView()
        tableView.headerView = nil
        tableView.rowHeight = 24

        let column = NSTableColumn(identifier: NSUserInterfaceItemIdentifier("FileColumn"))
        column.title = "Files"
        tableView.addTableColumn(column)

        tableView.dataSource = self
        tableView.delegate = self
        tableView.target = self
        tableView.doubleAction = #selector(handleDoubleClick(_:))

        scrollView.documentView = tableView

        // Constraints
        NSLayoutConstraint.activate([
            searchField.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 12),
            searchField.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 12),
            searchField.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -12),

            scrollView.topAnchor.constraint(equalTo: searchField.bottomAnchor, constant: 8),
            scrollView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 12),
            scrollView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -12),
            scrollView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -12)
        ])
    }

    override func showWindow(_ sender: Any?) {
        super.showWindow(sender)
        window?.makeFirstResponder(searchField)
        searchField.stringValue = ""
        searchResults = []
        tableView.reloadData()
    }

    @objc private func searchFieldChanged(_ sender: NSSearchField) {
        let query = sender.stringValue
        if query.isEmpty {
            searchResults = []
        } else {
            searchResults = workspaceManager?.searchFiles(matching: query) ?? []
        }
        tableView.reloadData()
    }

    @objc private func handleDoubleClick(_ sender: Any?) {
        let row = tableView.clickedRow
        guard row >= 0, row < searchResults.count else { return }

        let url = searchResults[row]
        onFileSelected?(url)
        close()
    }
}

// MARK: - NSTableViewDataSource

extension QuickOpenController: NSTableViewDataSource {

    func numberOfRows(in tableView: NSTableView) -> Int {
        return searchResults.count
    }
}

// MARK: - NSTableViewDelegate

extension QuickOpenController: NSTableViewDelegate {

    func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -> NSView? {
        guard row < searchResults.count else { return nil }

        let url = searchResults[row]
        let cellIdentifier = NSUserInterfaceItemIdentifier("FileCell")
        var cell = tableView.makeView(withIdentifier: cellIdentifier, owner: self) as? NSTableCellView

        if cell == nil {
            cell = NSTableCellView()
            cell?.identifier = cellIdentifier

            let textField = NSTextField(labelWithString: "")
            textField.translatesAutoresizingMaskIntoConstraints = false
            cell?.addSubview(textField)
            cell?.textField = textField

            NSLayoutConstraint.activate([
                textField.leadingAnchor.constraint(equalTo: cell!.leadingAnchor, constant: 4),
                textField.trailingAnchor.constraint(equalTo: cell!.trailingAnchor, constant: -4),
                textField.centerYAnchor.constraint(equalTo: cell!.centerYAnchor)
            ])
        }

        // Show relative path from workspace root
        if let root = workspaceManager?.workspaceRoot {
            let relativePath = url.path.replacingOccurrences(of: root.path + "/", with: "")
            cell?.textField?.stringValue = relativePath
        } else {
            cell?.textField?.stringValue = url.lastPathComponent
        }

        return cell
    }
}
```

**Step 2: Commit**

```bash
git add Sources/MarkdownEditor/Workspace/QuickOpenController.swift
git commit -m "feat(sidebar): add QuickOpenController for Cmd+P file search"
```

---

## Task 5: Integration

**Step 1: Final commit**

```bash
git add -A
git commit -m "feat(sidebar): complete sidebar module

- WorkspaceManager for mounting/unmounting workspaces
- FileWatcher with FSEvents for directory monitoring
- SidebarController with NSOutlineView file tree
- QuickOpenController for Cmd+P file search

Implements WorkspaceProviding protocol from scaffolding."
```

---

## What This Module Delivers

| Component | Purpose |
|-----------|---------|
| `WorkspaceManager` | Workspace state, file tree enumeration, search |
| `FileWatcher` | FSEvents-based directory monitoring |
| `SidebarController` | NSOutlineView for file tree display |
| `QuickOpenController` | Cmd+P fuzzy file search panel |
