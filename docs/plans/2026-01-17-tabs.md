# Tabs Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement multi-document tab management with tab bar UI, document lifecycle, dirty state tracking, and save prompts.

**Architecture:** `TabManager` owns document instances and tab state. `TabBarView` displays tabs and handles user interaction. Implements `TabManaging` protocol from scaffolding.

**Tech Stack:** Swift 5.9+, AppKit (NSView, NSStackView)

---

## Prerequisites

- Scaffolding must be complete (provides `TabManaging` protocol, `TabInfo` type, `DocumentModel`)
- No dependencies on other modules — tabs work independently

---

## What You're Building

A tab system that:
1. Manages multiple open documents
2. Shows a tab bar with document titles and dirty indicators
3. Handles document lifecycle (open, close, save prompts)
4. Tracks dirty state and shows unsaved indicators

---

## Project Structure (additions to scaffolding)

```
Sources/MarkdownEditor/
├── Tabs/
│   ├── TabManager.swift              ← Document lifecycle management
│   ├── TabBarView.swift              ← Tab bar UI
│   └── TabView.swift                 ← Individual tab view
└── Tests/
    └── MarkdownEditorTests/
        └── Tabs/
            └── TabManagerTests.swift
```

---

## Task 1: TabManager

**Files:**
- Create: `Sources/MarkdownEditor/Tabs/TabManager.swift`
- Create: `Tests/MarkdownEditorTests/Tabs/TabManagerTests.swift`

**Step 1: Write failing test**

```swift
import XCTest
@testable import MarkdownEditor

final class TabManagerTests: XCTestCase {

    func testOpenDocument() {
        let manager = TabManager()
        let document = DocumentModel()

        manager.openDocument(document)

        XCTAssertEqual(manager.tabs.count, 1)
        XCTAssertEqual(manager.activeDocumentId, document.id)
    }

    func testOpenMultipleDocuments() {
        let manager = TabManager()
        let doc1 = DocumentModel()
        let doc2 = DocumentModel()

        manager.openDocument(doc1)
        manager.openDocument(doc2)

        XCTAssertEqual(manager.tabs.count, 2)
        XCTAssertEqual(manager.activeDocumentId, doc2.id)  // Most recent is active
    }

    func testCloseTab() {
        let manager = TabManager()
        let document = DocumentModel()

        manager.openDocument(document)
        let closed = manager.closeTab(documentId: document.id)

        XCTAssertTrue(closed)
        XCTAssertEqual(manager.tabs.count, 0)
        XCTAssertNil(manager.activeDocumentId)
    }

    func testActivateTab() {
        let manager = TabManager()
        let doc1 = DocumentModel()
        let doc2 = DocumentModel()

        manager.openDocument(doc1)
        manager.openDocument(doc2)

        manager.activateTab(documentId: doc1.id)

        XCTAssertEqual(manager.activeDocumentId, doc1.id)
    }

    func testTabInfo() {
        let manager = TabManager()
        let document = DocumentModel()
        document.filePath = URL(fileURLWithPath: "/path/to/file.md")

        manager.openDocument(document)

        let tab = manager.tabs.first
        XCTAssertNotNil(tab)
        XCTAssertEqual(tab?.title, "file.md")
        XCTAssertFalse(tab?.isDirty ?? true)
    }

    func testDirtyState() {
        let manager = TabManager()
        let document = DocumentModel()

        manager.openDocument(document)
        document.isDirty = true

        let tab = manager.tabs.first
        XCTAssertTrue(tab?.isDirty ?? false)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `swift test --filter TabManagerTests`
Expected: FAIL

**Step 3: Create TabManager**

```swift
import Foundation

/// Manages open documents and tab state.
///
/// Implements `TabManaging` protocol from scaffolding.
/// Owns document instances and tracks which is active.
final class TabManager: TabManaging {

    /// Documents keyed by ID.
    private var documents: [UUID: DocumentModel] = [:]

    /// Tab order (document IDs in display order).
    private var tabOrder: [UUID] = []

    /// Currently active document ID.
    private(set) var activeDocumentId: UUID?

    /// Callback when active tab changes.
    var onActiveTabChanged: ((UUID?) -> Void)?

    /// Callback before closing a dirty document (for save prompts).
    /// Return true to proceed with close, false to cancel.
    var onCloseConfirmation: ((DocumentModel) -> Bool)?

    // MARK: - TabManaging

    var tabs: [TabInfo] {
        return tabOrder.compactMap { id in
            guard let doc = documents[id] else { return nil }
            return TabInfo(
                documentId: doc.id,
                title: doc.filePath?.lastPathComponent ?? "Untitled",
                isDirty: doc.isDirty,
                filePath: doc.filePath
            )
        }
    }

    func openDocument(_ document: DocumentModel) {
        // Check if already open
        if documents[document.id] != nil {
            activateTab(documentId: document.id)
            return
        }

        documents[document.id] = document
        tabOrder.append(document.id)
        activateTab(documentId: document.id)
    }

    func closeTab(documentId: UUID) -> Bool {
        guard let document = documents[documentId] else { return false }

        // Check if dirty and prompt for save
        if document.isDirty {
            if let confirmation = onCloseConfirmation {
                if !confirmation(document) {
                    return false  // User cancelled
                }
            }
        }

        // Remove from data structures
        documents.removeValue(forKey: documentId)
        tabOrder.removeAll { $0 == documentId }

        // Update active tab
        if activeDocumentId == documentId {
            activeDocumentId = tabOrder.last
            onActiveTabChanged?(activeDocumentId)
        }

        return true
    }

    func activateTab(documentId: UUID) {
        guard documents[documentId] != nil else { return }

        activeDocumentId = documentId
        onActiveTabChanged?(documentId)
    }

    // MARK: - Document Access

    /// Get document by ID.
    func document(for id: UUID) -> DocumentModel? {
        return documents[id]
    }

    /// Get the active document.
    var activeDocument: DocumentModel? {
        guard let id = activeDocumentId else { return nil }
        return documents[id]
    }

    // MARK: - File Operations

    /// Open document from file, reusing existing tab if already open.
    func openFile(at url: URL) throws -> DocumentModel {
        // Check if already open
        if let existing = documents.values.first(where: { $0.filePath == url }) {
            activateTab(documentId: existing.id)
            return existing
        }

        let document = try DocumentModel(contentsOf: url)
        openDocument(document)
        return document
    }

    /// Create new untitled document.
    func newDocument() -> DocumentModel {
        let document = DocumentModel()
        openDocument(document)
        return document
    }

    /// Close all tabs, prompting for unsaved changes.
    /// Returns true if all closed, false if user cancelled.
    func closeAll() -> Bool {
        let idsToClose = tabOrder
        for id in idsToClose {
            if !closeTab(documentId: id) {
                return false
            }
        }
        return true
    }
}
```

**Step 4: Run tests**

Run: `swift test --filter TabManagerTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add Sources/MarkdownEditor/Tabs/TabManager.swift
git add Tests/MarkdownEditorTests/Tabs/TabManagerTests.swift
git commit -m "feat(tabs): add TabManager for document lifecycle"
```

---

## Task 2: TabView (Individual Tab)

**Files:**
- Create: `Sources/MarkdownEditor/Tabs/TabView.swift`

**Step 1: Create TabView**

```swift
import AppKit

/// View for a single tab in the tab bar.
///
/// Shows title, dirty indicator, and close button.
final class TabView: NSView {

    /// Tab info for display.
    var tabInfo: TabInfo? {
        didSet {
            updateDisplay()
        }
    }

    /// Whether this tab is active.
    var isActive: Bool = false {
        didSet {
            updateAppearance()
        }
    }

    /// Callback when tab is clicked.
    var onActivate: (() -> Void)?

    /// Callback when close button is clicked.
    var onClose: (() -> Void)?

    private var titleLabel: NSTextField!
    private var dirtyIndicator: NSView!
    private var closeButton: NSButton!

    // MARK: - Initialization

    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        setupViews()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupViews()
    }

    private func setupViews() {
        wantsLayer = true

        // Title label
        titleLabel = NSTextField(labelWithString: "Untitled")
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        titleLabel.font = .systemFont(ofSize: 12)
        titleLabel.lineBreakMode = .byTruncatingTail
        addSubview(titleLabel)

        // Dirty indicator (dot)
        dirtyIndicator = NSView()
        dirtyIndicator.translatesAutoresizingMaskIntoConstraints = false
        dirtyIndicator.wantsLayer = true
        dirtyIndicator.layer?.backgroundColor = NSColor.systemOrange.cgColor
        dirtyIndicator.layer?.cornerRadius = 3
        dirtyIndicator.isHidden = true
        addSubview(dirtyIndicator)

        // Close button
        closeButton = NSButton()
        closeButton.translatesAutoresizingMaskIntoConstraints = false
        closeButton.bezelStyle = .inline
        closeButton.isBordered = false
        closeButton.image = NSImage(systemSymbolName: "xmark", accessibilityDescription: "Close")
        closeButton.target = self
        closeButton.action = #selector(closeButtonClicked)
        addSubview(closeButton)

        // Constraints
        NSLayoutConstraint.activate([
            dirtyIndicator.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
            dirtyIndicator.centerYAnchor.constraint(equalTo: centerYAnchor),
            dirtyIndicator.widthAnchor.constraint(equalToConstant: 6),
            dirtyIndicator.heightAnchor.constraint(equalToConstant: 6),

            titleLabel.leadingAnchor.constraint(equalTo: dirtyIndicator.trailingAnchor, constant: 6),
            titleLabel.centerYAnchor.constraint(equalTo: centerYAnchor),
            titleLabel.trailingAnchor.constraint(lessThanOrEqualTo: closeButton.leadingAnchor, constant: -4),

            closeButton.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -4),
            closeButton.centerYAnchor.constraint(equalTo: centerYAnchor),
            closeButton.widthAnchor.constraint(equalToConstant: 16),
            closeButton.heightAnchor.constraint(equalToConstant: 16)
        ])

        // Click gesture for activation
        let click = NSClickGestureRecognizer(target: self, action: #selector(tabClicked))
        addGestureRecognizer(click)

        updateAppearance()
    }

    private func updateDisplay() {
        titleLabel.stringValue = tabInfo?.title ?? "Untitled"
        dirtyIndicator.isHidden = !(tabInfo?.isDirty ?? false)
    }

    private func updateAppearance() {
        if isActive {
            layer?.backgroundColor = NSColor.controlAccentColor.withAlphaComponent(0.2).cgColor
        } else {
            layer?.backgroundColor = NSColor.clear.cgColor
        }
    }

    @objc private func tabClicked() {
        onActivate?()
    }

    @objc private func closeButtonClicked() {
        onClose?()
    }

    // MARK: - Layout

    override var intrinsicContentSize: NSSize {
        return NSSize(width: 150, height: 28)
    }
}
```

**Step 2: Commit**

```bash
git add Sources/MarkdownEditor/Tabs/TabView.swift
git commit -m "feat(tabs): add TabView for individual tab display"
```

---

## Task 3: TabBarView

**Files:**
- Create: `Sources/MarkdownEditor/Tabs/TabBarView.swift`

**Step 1: Create TabBarView**

```swift
import AppKit

/// View containing all tabs in a horizontal bar.
///
/// Uses NSStackView for horizontal layout of tabs.
final class TabBarView: NSView {

    /// Tab manager providing tab state.
    weak var tabManager: TabManager? {
        didSet {
            rebuildTabs()
        }
    }

    /// Stack view containing tabs.
    private var stackView: NSStackView!

    /// Tab views keyed by document ID.
    private var tabViews: [UUID: TabView] = [:]

    // MARK: - Initialization

    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        setupViews()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupViews()
    }

    private func setupViews() {
        wantsLayer = true
        layer?.backgroundColor = NSColor.windowBackgroundColor.cgColor

        stackView = NSStackView()
        stackView.translatesAutoresizingMaskIntoConstraints = false
        stackView.orientation = .horizontal
        stackView.spacing = 1
        stackView.alignment = .centerY
        stackView.distribution = .fill
        addSubview(stackView)

        NSLayoutConstraint.activate([
            stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
            stackView.trailingAnchor.constraint(lessThanOrEqualTo: trailingAnchor),
            stackView.topAnchor.constraint(equalTo: topAnchor),
            stackView.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])
    }

    // MARK: - Tab Management

    /// Rebuild all tabs from tab manager state.
    func rebuildTabs() {
        // Remove old tabs
        for tabView in tabViews.values {
            tabView.removeFromSuperview()
        }
        tabViews.removeAll()

        // Create new tabs
        guard let manager = tabManager else { return }

        for tabInfo in manager.tabs {
            let tabView = TabView()
            tabView.tabInfo = tabInfo
            tabView.isActive = tabInfo.documentId == manager.activeDocumentId

            tabView.onActivate = { [weak self, weak manager] in
                manager?.activateTab(documentId: tabInfo.documentId)
                self?.updateActiveStates()
            }

            tabView.onClose = { [weak manager] in
                _ = manager?.closeTab(documentId: tabInfo.documentId)
            }

            stackView.addArrangedSubview(tabView)
            tabViews[tabInfo.documentId] = tabView
        }
    }

    /// Update tab info (e.g., after dirty state changes).
    func updateTabs() {
        guard let manager = tabManager else { return }

        for tabInfo in manager.tabs {
            tabViews[tabInfo.documentId]?.tabInfo = tabInfo
        }
        updateActiveStates()
    }

    private func updateActiveStates() {
        guard let manager = tabManager else { return }

        for (id, tabView) in tabViews {
            tabView.isActive = id == manager.activeDocumentId
        }
    }

    // MARK: - Layout

    override var intrinsicContentSize: NSSize {
        return NSSize(width: NSView.noIntrinsicMetric, height: 32)
    }
}
```

**Step 2: Commit**

```bash
git add Sources/MarkdownEditor/Tabs/TabBarView.swift
git commit -m "feat(tabs): add TabBarView for horizontal tab bar"
```

---

## Task 4: Integration

**Step 1: Final commit**

```bash
git add -A
git commit -m "feat(tabs): complete tabs module

- TabManager for document lifecycle and state
- TabView for individual tab display
- TabBarView for horizontal tab bar
- Dirty state tracking and close confirmation

Implements TabManaging protocol from scaffolding."
```

---

## What This Module Delivers

| Component | Purpose |
|-----------|---------|
| `TabManager` | Document lifecycle, tab state, active tracking |
| `TabView` | Individual tab with title, dirty indicator, close |
| `TabBarView` | Horizontal container for tabs |
