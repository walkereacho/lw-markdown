# Parser Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a Markdown parser that converts text into tokens describing element types and ranges, enabling the rendering module to display formatted Markdown.

**Architecture:** Pure function parser — text in, tokens out. No side effects, no storage interaction. Block context scanner handles multi-paragraph constructs (fenced code blocks). Parser is stateless; context comes from DocumentModel's block context.

**Tech Stack:** Swift 5.9+, Swift Regex (new in Swift 5.7)

---

## Prerequisites

- Scaffolding must be complete (provides `MarkdownToken`, `MarkdownElement` types)
- You implement `TokenProviding` protocol from scaffolding
- No dependencies on other modules — parser works in isolation

---

## What You're Building

The parser takes paragraph text and returns tokens:

```swift
let parser = MarkdownParser()
let tokens = parser.parse("This is **bold** and *italic*")

// Returns:
// [
//   MarkdownToken(element: .bold, contentRange: 8..<12, syntaxRanges: [7..<9, 12..<14]),
//   MarkdownToken(element: .italic, contentRange: 20..<26, syntaxRanges: [19..<20, 26..<27])
// ]
```

**Key Concepts:**
- `contentRange`: The text to display (e.g., "bold" in `**bold**`)
- `syntaxRanges`: Characters to hide when formatted (e.g., the `**` markers)

---

## Markdown Elements to Parse

### Block-Level (One Per Paragraph)

| Element | Pattern | Example |
|---------|---------|---------|
| Heading | `^#{1,6}\s+` | `# Title`, `## Section` |
| Blockquote | `^>\s+` | `> Quote text` |
| Unordered List | `^[-*+]\s+` | `- Item`, `* Item` |
| Ordered List | `^\d+\.\s+` | `1. First`, `2. Second` |
| Horizontal Rule | `^---$`, `^***$`, `^___$` | `---` |
| Fenced Code Fence | `^\`\`\``, `^~~~` | ` ```swift ` |

### Inline (Multiple Per Paragraph)

| Element | Pattern | Example |
|---------|---------|---------|
| Bold | `**text**`, `__text__` | `**bold**` |
| Italic | `*text*`, `_text_` | `*italic*` |
| Bold+Italic | `***text***` | `***both***` |
| Inline Code | `` `code` `` | `` `let x = 1` `` |
| Link | `[text](url)` | `[Click](https://...)` |

---

## Project Structure (additions to scaffolding)

```
Sources/MarkdownEditor/
├── Parser/
│   ├── MarkdownParser.swift          ← Main parser
│   ├── BlockContextScanner.swift     ← Fenced code block detection
│   └── BlockContext.swift            ← Block context data structure
└── Tests/
    └── MarkdownEditorTests/
        └── Parser/
            ├── HeadingParserTests.swift
            ├── EmphasisParserTests.swift
            ├── ListParserTests.swift
            ├── LinkParserTests.swift
            ├── CodeBlockTests.swift
            └── BlockContextTests.swift
```

---

## Task 1: MarkdownParser Foundation

**Files:**
- Create: `Sources/MarkdownEditor/Parser/MarkdownParser.swift`
- Create: `Tests/MarkdownEditorTests/Parser/HeadingParserTests.swift`

**Step 1: Write failing test for headings**

```swift
import XCTest
@testable import MarkdownEditor

final class HeadingParserTests: XCTestCase {

    let parser = MarkdownParser()

    func testH1Heading() {
        let tokens = parser.parse("# Hello World")

        XCTAssertEqual(tokens.count, 1)
        guard case .heading(let level) = tokens[0].element else {
            XCTFail("Expected heading element")
            return
        }
        XCTAssertEqual(level, 1)
        XCTAssertEqual(tokens[0].contentRange, 2..<13)  // "Hello World"
        XCTAssertEqual(tokens[0].syntaxRanges, [0..<1])  // "#"
    }

    func testH2Heading() {
        let tokens = parser.parse("## Section Title")

        XCTAssertEqual(tokens.count, 1)
        guard case .heading(let level) = tokens[0].element else {
            XCTFail("Expected heading element")
            return
        }
        XCTAssertEqual(level, 2)
    }

    func testH6Heading() {
        let tokens = parser.parse("###### Deep")

        XCTAssertEqual(tokens.count, 1)
        guard case .heading(let level) = tokens[0].element else {
            XCTFail("Expected heading element")
            return
        }
        XCTAssertEqual(level, 6)
    }

    func testNotHeadingWithoutSpace() {
        // "#NoSpace" is not a heading - requires space after #
        let tokens = parser.parse("#NoSpace")

        // Should return no heading tokens (just plain text)
        let headingTokens = tokens.filter {
            if case .heading = $0.element { return true }
            return false
        }
        XCTAssertEqual(headingTokens.count, 0)
    }

    func testHeadingMaxLevel() {
        // 7 hashes is not a valid heading
        let tokens = parser.parse("####### Too Many")

        let headingTokens = tokens.filter {
            if case .heading = $0.element { return true }
            return false
        }
        XCTAssertEqual(headingTokens.count, 0)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `swift test --filter HeadingParserTests`
Expected: FAIL with "MarkdownParser not found"

**Step 3: Create MarkdownParser with heading support**

```swift
import Foundation

/// Parser that converts Markdown text to tokens.
///
/// ## Design Principles
/// - Pure function: text in, tokens out
/// - No side effects, no storage interaction
/// - Stateless — block context provided externally
/// - Tokens describe structure; rendering is separate concern
final class MarkdownParser: TokenProviding {

    static let shared = MarkdownParser()

    // MARK: - TokenProviding

    func parse(_ text: String) -> [MarkdownToken] {
        var tokens: [MarkdownToken] = []

        // Check block-level elements first (mutually exclusive)
        if let headingToken = parseHeading(text) {
            tokens.append(headingToken)
            return tokens
        }

        // TODO: Add more block-level parsers

        // TODO: Parse inline elements

        return tokens
    }

    // MARK: - Block-Level Parsing

    private func parseHeading(_ text: String) -> MarkdownToken? {
        // Pattern: 1-6 # characters, followed by space, then content
        // ^(#{1,6})\s+(.+)$
        let pattern = /^(#{1,6})\s+(.+)$/

        guard let match = text.wholeMatch(of: pattern) else { return nil }

        let hashes = String(match.1)
        let level = hashes.count
        let contentStart = level + 1  // hashes + space
        let contentEnd = text.count

        return MarkdownToken(
            element: .heading(level: level),
            contentRange: contentStart..<contentEnd,
            syntaxRanges: [0..<level]
        )
    }
}
```

**Step 4: Run tests**

Run: `swift test --filter HeadingParserTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add Sources/MarkdownEditor/Parser/MarkdownParser.swift
git add Tests/MarkdownEditorTests/Parser/HeadingParserTests.swift
git commit -m "feat(parser): add MarkdownParser with heading support"
```

---

## Task 2: Blockquote and List Parsing

**Files:**
- Modify: `Sources/MarkdownEditor/Parser/MarkdownParser.swift`
- Create: `Tests/MarkdownEditorTests/Parser/ListParserTests.swift`

**Step 1: Write failing tests**

```swift
import XCTest
@testable import MarkdownEditor

final class ListParserTests: XCTestCase {

    let parser = MarkdownParser()

    // MARK: - Blockquotes

    func testBlockquote() {
        let tokens = parser.parse("> This is quoted")

        XCTAssertEqual(tokens.count, 1)
        guard case .blockquote = tokens[0].element else {
            XCTFail("Expected blockquote element")
            return
        }
        XCTAssertEqual(tokens[0].contentRange, 2..<16)  // "This is quoted"
        XCTAssertEqual(tokens[0].syntaxRanges, [0..<2])  // "> "
    }

    // MARK: - Unordered Lists

    func testUnorderedListDash() {
        let tokens = parser.parse("- List item")

        XCTAssertEqual(tokens.count, 1)
        guard case .unorderedListItem = tokens[0].element else {
            XCTFail("Expected unordered list item")
            return
        }
        XCTAssertEqual(tokens[0].contentRange, 2..<11)
        XCTAssertEqual(tokens[0].syntaxRanges, [0..<2])
    }

    func testUnorderedListAsterisk() {
        let tokens = parser.parse("* Another item")

        XCTAssertEqual(tokens.count, 1)
        guard case .unorderedListItem = tokens[0].element else {
            XCTFail("Expected unordered list item")
            return
        }
    }

    func testUnorderedListPlus() {
        let tokens = parser.parse("+ Plus item")

        XCTAssertEqual(tokens.count, 1)
        guard case .unorderedListItem = tokens[0].element else {
            XCTFail("Expected unordered list item")
            return
        }
    }

    // MARK: - Ordered Lists

    func testOrderedList() {
        let tokens = parser.parse("1. First item")

        XCTAssertEqual(tokens.count, 1)
        guard case .orderedListItem(let number) = tokens[0].element else {
            XCTFail("Expected ordered list item")
            return
        }
        XCTAssertEqual(number, 1)
        XCTAssertEqual(tokens[0].contentRange, 3..<13)  // "First item"
        XCTAssertEqual(tokens[0].syntaxRanges, [0..<3])  // "1. "
    }

    func testOrderedListLargeNumber() {
        let tokens = parser.parse("42. Answer")

        XCTAssertEqual(tokens.count, 1)
        guard case .orderedListItem(let number) = tokens[0].element else {
            XCTFail("Expected ordered list item")
            return
        }
        XCTAssertEqual(number, 42)
    }

    // MARK: - Horizontal Rule

    func testHorizontalRuleDashes() {
        let tokens = parser.parse("---")

        XCTAssertEqual(tokens.count, 1)
        guard case .horizontalRule = tokens[0].element else {
            XCTFail("Expected horizontal rule")
            return
        }
        XCTAssertEqual(tokens[0].syntaxRanges, [0..<3])
    }

    func testHorizontalRuleAsterisks() {
        let tokens = parser.parse("***")

        XCTAssertEqual(tokens.count, 1)
        guard case .horizontalRule = tokens[0].element else {
            XCTFail("Expected horizontal rule")
            return
        }
    }

    func testHorizontalRuleUnderscores() {
        let tokens = parser.parse("___")

        XCTAssertEqual(tokens.count, 1)
        guard case .horizontalRule = tokens[0].element else {
            XCTFail("Expected horizontal rule")
            return
        }
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `swift test --filter ListParserTests`
Expected: FAIL

**Step 3: Add block-level parsers**

Add to `MarkdownParser.swift`:

```swift
// In parse(_:) method, after heading check:
if let blockquoteToken = parseBlockquote(text) {
    tokens.append(blockquoteToken)
    return tokens
}

if let listToken = parseListItem(text) {
    tokens.append(listToken)
    return tokens
}

if let hrToken = parseHorizontalRule(text) {
    tokens.append(hrToken)
    return tokens
}

// Add these private methods:

private func parseBlockquote(_ text: String) -> MarkdownToken? {
    guard text.hasPrefix("> ") else { return nil }

    return MarkdownToken(
        element: .blockquote,
        contentRange: 2..<text.count,
        syntaxRanges: [0..<2]
    )
}

private func parseListItem(_ text: String) -> MarkdownToken? {
    // Unordered: - item, * item, + item
    let unorderedPattern = /^([-*+])\s+(.+)$/

    if let match = text.wholeMatch(of: unorderedPattern) {
        let markerLength = 1  // -, *, or +
        let syntaxLength = markerLength + 1  // marker + space
        return MarkdownToken(
            element: .unorderedListItem,
            contentRange: syntaxLength..<text.count,
            syntaxRanges: [0..<syntaxLength]
        )
    }

    // Ordered: 1. item, 2. item, etc.
    let orderedPattern = /^(\d+)\.\s+(.+)$/

    if let match = text.wholeMatch(of: orderedPattern) {
        let numberStr = String(match.1)
        let number = Int(numberStr) ?? 1
        let syntaxLength = numberStr.count + 2  // number + ". "
        return MarkdownToken(
            element: .orderedListItem(number: number),
            contentRange: syntaxLength..<text.count,
            syntaxRanges: [0..<syntaxLength]
        )
    }

    return nil
}

private func parseHorizontalRule(_ text: String) -> MarkdownToken? {
    let trimmed = text.trimmingCharacters(in: .whitespaces)

    // Must be at least 3 of the same character
    guard trimmed.count >= 3 else { return nil }

    let patterns = ["---", "***", "___"]

    for pattern in patterns {
        guard let firstChar = pattern.first else { continue }

        // Check if line is only this character (and spaces)
        if trimmed.hasPrefix(pattern) &&
           trimmed.allSatisfy({ $0 == firstChar || $0 == " " }) {
            return MarkdownToken(
                element: .horizontalRule,
                contentRange: 0..<0,  // No content
                syntaxRanges: [0..<text.count]
            )
        }
    }

    return nil
}
```

**Step 4: Run tests**

Run: `swift test --filter ListParserTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add Sources/MarkdownEditor/Parser/MarkdownParser.swift
git add Tests/MarkdownEditorTests/Parser/ListParserTests.swift
git commit -m "feat(parser): add blockquote, list, and horizontal rule parsing"
```

---

## Task 3: Emphasis Parsing (Bold, Italic)

**Files:**
- Modify: `Sources/MarkdownEditor/Parser/MarkdownParser.swift`
- Create: `Tests/MarkdownEditorTests/Parser/EmphasisParserTests.swift`

**Step 1: Write failing tests**

```swift
import XCTest
@testable import MarkdownEditor

final class EmphasisParserTests: XCTestCase {

    let parser = MarkdownParser()

    // MARK: - Bold

    func testBoldAsterisks() {
        let tokens = parser.parse("This is **bold** text")

        let boldTokens = tokens.filter {
            if case .bold = $0.element { return true }
            return false
        }
        XCTAssertEqual(boldTokens.count, 1)
        XCTAssertEqual(boldTokens[0].contentRange, 10..<14)  // "bold"
        XCTAssertEqual(boldTokens[0].syntaxRanges.count, 2)
        XCTAssertEqual(boldTokens[0].syntaxRanges[0], 8..<10)   // **
        XCTAssertEqual(boldTokens[0].syntaxRanges[1], 14..<16)  // **
    }

    func testBoldUnderscores() {
        let tokens = parser.parse("This is __bold__ text")

        let boldTokens = tokens.filter {
            if case .bold = $0.element { return true }
            return false
        }
        XCTAssertEqual(boldTokens.count, 1)
    }

    // MARK: - Italic

    func testItalicAsterisk() {
        let tokens = parser.parse("This is *italic* text")

        let italicTokens = tokens.filter {
            if case .italic = $0.element { return true }
            return false
        }
        XCTAssertEqual(italicTokens.count, 1)
        XCTAssertEqual(italicTokens[0].contentRange, 9..<15)  // "italic"
        XCTAssertEqual(italicTokens[0].syntaxRanges[0], 8..<9)   // *
        XCTAssertEqual(italicTokens[0].syntaxRanges[1], 15..<16)  // *
    }

    func testItalicUnderscore() {
        let tokens = parser.parse("This is _italic_ text")

        let italicTokens = tokens.filter {
            if case .italic = $0.element { return true }
            return false
        }
        XCTAssertEqual(italicTokens.count, 1)
    }

    // MARK: - Bold + Italic

    func testBoldItalic() {
        let tokens = parser.parse("This is ***both*** text")

        let boldItalicTokens = tokens.filter {
            if case .boldItalic = $0.element { return true }
            return false
        }
        XCTAssertEqual(boldItalicTokens.count, 1)
        XCTAssertEqual(boldItalicTokens[0].contentRange, 11..<15)  // "both"
    }

    // MARK: - Multiple Emphasis

    func testMultipleEmphasis() {
        let tokens = parser.parse("**bold** and *italic*")

        let boldTokens = tokens.filter {
            if case .bold = $0.element { return true }
            return false
        }
        let italicTokens = tokens.filter {
            if case .italic = $0.element { return true }
            return false
        }

        XCTAssertEqual(boldTokens.count, 1)
        XCTAssertEqual(italicTokens.count, 1)
    }

    // MARK: - Inline Code

    func testInlineCode() {
        let tokens = parser.parse("Use `let x = 1` here")

        let codeTokens = tokens.filter {
            if case .inlineCode = $0.element { return true }
            return false
        }
        XCTAssertEqual(codeTokens.count, 1)
        XCTAssertEqual(codeTokens[0].contentRange, 5..<14)  // "let x = 1"
        XCTAssertEqual(codeTokens[0].syntaxRanges[0], 4..<5)   // `
        XCTAssertEqual(codeTokens[0].syntaxRanges[1], 14..<15)  // `
    }

    func testInlineCodeDoesNotParseEmphasis() {
        // Asterisks inside code should not be parsed as emphasis
        let tokens = parser.parse("`**not bold**`")

        let boldTokens = tokens.filter {
            if case .bold = $0.element { return true }
            return false
        }
        let codeTokens = tokens.filter {
            if case .inlineCode = $0.element { return true }
            return false
        }

        XCTAssertEqual(boldTokens.count, 0)
        XCTAssertEqual(codeTokens.count, 1)
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `swift test --filter EmphasisParserTests`
Expected: FAIL

**Step 3: Add inline parsing**

Add to `MarkdownParser.swift`:

```swift
// At end of parse(_:) method, before return:
tokens.append(contentsOf: parseInlineElements(text))

return tokens

// Add these private methods:

private func parseInlineElements(_ text: String) -> [MarkdownToken] {
    var tokens: [MarkdownToken] = []

    // Parse inline code first (contents should not be parsed for emphasis)
    let codeRanges = parseInlineCode(text)
    tokens.append(contentsOf: codeRanges.map { $0.token })

    // Parse emphasis, avoiding code regions
    let excludedRanges = codeRanges.map { $0.fullRange }

    // Bold italic first (***text***)
    tokens.append(contentsOf: parseEmphasis(
        in: text,
        pattern: /\*\*\*(.+?)\*\*\*/,
        element: .boldItalic,
        syntaxLength: 3,
        excluding: excludedRanges
    ))

    // Bold (**text** or __text__)
    tokens.append(contentsOf: parseEmphasis(
        in: text,
        pattern: /\*\*(.+?)\*\*/,
        element: .bold,
        syntaxLength: 2,
        excluding: excludedRanges
    ))
    tokens.append(contentsOf: parseEmphasis(
        in: text,
        pattern: /__(.+?)__/,
        element: .bold,
        syntaxLength: 2,
        excluding: excludedRanges
    ))

    // Italic (*text* or _text_)
    // Use negative lookbehind/lookahead to avoid matching ** or __
    tokens.append(contentsOf: parseEmphasis(
        in: text,
        pattern: /(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/,
        element: .italic,
        syntaxLength: 1,
        excluding: excludedRanges
    ))
    tokens.append(contentsOf: parseEmphasis(
        in: text,
        pattern: /(?<!_)_(?!_)(.+?)(?<!_)_(?!_)/,
        element: .italic,
        syntaxLength: 1,
        excluding: excludedRanges
    ))

    return tokens
}

private struct InlineCodeMatch {
    let token: MarkdownToken
    let fullRange: Range<Int>
}

private func parseInlineCode(_ text: String) -> [InlineCodeMatch] {
    var matches: [InlineCodeMatch] = []

    let pattern = /`([^`]+)`/

    for match in text.matches(of: pattern) {
        let start = text.distance(from: text.startIndex, to: match.range.lowerBound)
        let end = text.distance(from: text.startIndex, to: match.range.upperBound)

        let contentStart = start + 1
        let contentEnd = end - 1

        let token = MarkdownToken(
            element: .inlineCode,
            contentRange: contentStart..<contentEnd,
            syntaxRanges: [start..<(start + 1), (end - 1)..<end]
        )

        matches.append(InlineCodeMatch(token: token, fullRange: start..<end))
    }

    return matches
}

private func parseEmphasis(
    in text: String,
    pattern: some RegexComponent,
    element: MarkdownElement,
    syntaxLength: Int,
    excluding: [Range<Int>]
) -> [MarkdownToken] {
    var tokens: [MarkdownToken] = []

    for match in text.matches(of: pattern) {
        let start = text.distance(from: text.startIndex, to: match.range.lowerBound)
        let end = text.distance(from: text.startIndex, to: match.range.upperBound)

        // Skip if this range overlaps with excluded ranges (e.g., code)
        let overlapsExcluded = excluding.contains { excluded in
            start < excluded.upperBound && end > excluded.lowerBound
        }
        if overlapsExcluded { continue }

        let contentStart = start + syntaxLength
        let contentEnd = end - syntaxLength

        tokens.append(MarkdownToken(
            element: element,
            contentRange: contentStart..<contentEnd,
            syntaxRanges: [
                start..<(start + syntaxLength),
                (end - syntaxLength)..<end
            ]
        ))
    }

    return tokens
}
```

**Step 4: Run tests**

Run: `swift test --filter EmphasisParserTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add Sources/MarkdownEditor/Parser/MarkdownParser.swift
git add Tests/MarkdownEditorTests/Parser/EmphasisParserTests.swift
git commit -m "feat(parser): add emphasis parsing (bold, italic, code)"
```

---

## Task 4: Link Parsing

**Files:**
- Modify: `Sources/MarkdownEditor/Parser/MarkdownParser.swift`
- Create: `Tests/MarkdownEditorTests/Parser/LinkParserTests.swift`

**Step 1: Write failing tests**

```swift
import XCTest
@testable import MarkdownEditor

final class LinkParserTests: XCTestCase {

    let parser = MarkdownParser()

    func testSimpleLink() {
        let tokens = parser.parse("Click [here](https://example.com) now")

        let linkTokens = tokens.filter {
            if case .link = $0.element { return true }
            return false
        }
        XCTAssertEqual(linkTokens.count, 1)

        guard case .link(let url) = linkTokens[0].element else {
            XCTFail("Expected link element")
            return
        }
        XCTAssertEqual(url, "https://example.com")
        XCTAssertEqual(linkTokens[0].contentRange, 7..<11)  // "here"
    }

    func testLinkWithSpacesInText() {
        let tokens = parser.parse("[Click here](https://example.com)")

        let linkTokens = tokens.filter {
            if case .link = $0.element { return true }
            return false
        }
        XCTAssertEqual(linkTokens.count, 1)

        guard case .link(let url) = linkTokens[0].element else {
            XCTFail("Expected link element")
            return
        }
        XCTAssertEqual(url, "https://example.com")
    }

    func testMultipleLinks() {
        let tokens = parser.parse("[A](a.com) and [B](b.com)")

        let linkTokens = tokens.filter {
            if case .link = $0.element { return true }
            return false
        }
        XCTAssertEqual(linkTokens.count, 2)
    }

    func testLinkSyntaxRanges() {
        let tokens = parser.parse("[text](url)")

        let linkTokens = tokens.filter {
            if case .link = $0.element { return true }
            return false
        }
        XCTAssertEqual(linkTokens.count, 1)

        // Syntax ranges should be: [, ](, )
        XCTAssertEqual(linkTokens[0].syntaxRanges.count, 3)
        XCTAssertEqual(linkTokens[0].syntaxRanges[0], 0..<1)   // [
        XCTAssertEqual(linkTokens[0].syntaxRanges[1], 5..<7)   // ](
        XCTAssertEqual(linkTokens[0].syntaxRanges[2], 10..<11) // )
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `swift test --filter LinkParserTests`
Expected: FAIL

**Step 3: Add link parsing**

Add to `parseInlineElements` in `MarkdownParser.swift`:

```swift
// At end of parseInlineElements, before return:
tokens.append(contentsOf: parseLinks(in: text, excluding: excludedRanges))

// Add this private method:

private func parseLinks(in text: String, excluding: [Range<Int>]) -> [MarkdownToken] {
    var tokens: [MarkdownToken] = []

    // Pattern: [text](url)
    let pattern = /\[([^\]]+)\]\(([^)]+)\)/

    for match in text.matches(of: pattern) {
        let start = text.distance(from: text.startIndex, to: match.range.lowerBound)
        let end = text.distance(from: text.startIndex, to: match.range.upperBound)

        // Skip if overlaps with excluded ranges
        let overlapsExcluded = excluding.contains { excluded in
            start < excluded.upperBound && end > excluded.lowerBound
        }
        if overlapsExcluded { continue }

        // Extract URL
        let url = String(match.2)

        // Find the bracket positions
        let fullText = String(text[match.range])
        guard let closeBracketIndex = fullText.firstIndex(of: "]") else { continue }

        let bracketOffset = fullText.distance(from: fullText.startIndex, to: closeBracketIndex)

        let contentStart = start + 1  // After [
        let contentEnd = start + bracketOffset  // Before ]

        let urlStart = contentEnd + 2  // After ](
        let urlEnd = end - 1  // Before )

        tokens.append(MarkdownToken(
            element: .link(url: url),
            contentRange: contentStart..<contentEnd,
            syntaxRanges: [
                start..<(start + 1),           // [
                contentEnd..<(contentEnd + 2),  // ](
                urlEnd..<end                    // ) — includes URL as syntax
            ]
        ))
    }

    return tokens
}
```

**Step 4: Run tests**

Run: `swift test --filter LinkParserTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add Sources/MarkdownEditor/Parser/MarkdownParser.swift
git add Tests/MarkdownEditorTests/Parser/LinkParserTests.swift
git commit -m "feat(parser): add link parsing"
```

---

## Task 5: Block Context for Fenced Code Blocks

**Files:**
- Create: `Sources/MarkdownEditor/Parser/BlockContext.swift`
- Create: `Sources/MarkdownEditor/Parser/BlockContextScanner.swift`
- Create: `Tests/MarkdownEditorTests/Parser/BlockContextTests.swift`

**Step 1: Write failing tests**

```swift
import XCTest
@testable import MarkdownEditor

final class BlockContextTests: XCTestCase {

    func testEmptyDocumentHasNoBlocks() {
        let context = BlockContext()
        XCTAssertEqual(context.fencedCodeBlocks.count, 0)
    }

    func testIsInsideFencedCodeBlock() {
        var context = BlockContext()
        context.fencedCodeBlocks = [(start: 2, end: 5, language: "swift")]

        // Paragraphs 3 and 4 are inside (exclusive of boundaries)
        XCTAssertTrue(context.isInsideFencedCodeBlock(paragraphIndex: 3).0)
        XCTAssertTrue(context.isInsideFencedCodeBlock(paragraphIndex: 4).0)

        // Boundaries themselves are not "inside"
        XCTAssertFalse(context.isInsideFencedCodeBlock(paragraphIndex: 2).0)
        XCTAssertFalse(context.isInsideFencedCodeBlock(paragraphIndex: 5).0)

        // Outside
        XCTAssertFalse(context.isInsideFencedCodeBlock(paragraphIndex: 0).0)
        XCTAssertFalse(context.isInsideFencedCodeBlock(paragraphIndex: 10).0)
    }

    func testIsFenceBoundary() {
        var context = BlockContext()
        context.fencedCodeBlocks = [(start: 2, end: 5, language: nil)]

        XCTAssertTrue(context.isFenceBoundary(paragraphIndex: 2))
        XCTAssertTrue(context.isFenceBoundary(paragraphIndex: 5))
        XCTAssertFalse(context.isFenceBoundary(paragraphIndex: 3))
    }

    func testLanguageExtraction() {
        var context = BlockContext()
        context.fencedCodeBlocks = [(start: 0, end: 3, language: "python")]

        let (isInside, language) = context.isInsideFencedCodeBlock(paragraphIndex: 1)
        XCTAssertTrue(isInside)
        XCTAssertEqual(language, "python")
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `swift test --filter BlockContextTests`
Expected: FAIL

**Step 3: Create BlockContext**

```swift
import Foundation

/// Identifies regions where paragraph-independence doesn't hold.
///
/// Some Markdown constructs span multiple paragraphs (fenced code blocks).
/// This structure tracks their boundaries so the parser can handle them correctly.
struct BlockContext {

    /// Ranges of fenced code blocks (paragraph indices).
    /// `start` is the opening fence, `end` is the closing fence.
    var fencedCodeBlocks: [(start: Int, end: Int, language: String?)] = []

    /// Check if a paragraph is inside a fenced code block (not on boundary).
    func isInsideFencedCodeBlock(paragraphIndex: Int) -> (Bool, String?) {
        for block in fencedCodeBlocks {
            // Inside means between start and end, exclusive
            if paragraphIndex > block.start && paragraphIndex < block.end {
                return (true, block.language)
            }
        }
        return (false, nil)
    }

    /// Check if a paragraph is a fence boundary (opening or closing).
    func isFenceBoundary(paragraphIndex: Int) -> Bool {
        for block in fencedCodeBlocks {
            if paragraphIndex == block.start || paragraphIndex == block.end {
                return true
            }
        }
        return false
    }
}
```

**Step 4: Run tests**

Run: `swift test --filter BlockContextTests`
Expected: All tests pass

**Step 5: Create BlockContextScanner**

```swift
import Foundation

/// Scans documents for multi-paragraph constructs.
///
/// Runs on document load (full scan) and incrementally on edits.
final class BlockContextScanner {

    /// Scan entire document for block constructs.
    /// O(N) where N = paragraph count.
    func scan(paragraphs: [String]) -> BlockContext {
        var context = BlockContext()
        var openFence: (index: Int, language: String?)? = nil

        for (i, text) in paragraphs.enumerated() {
            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)

            // Check for fence (``` or ~~~)
            if trimmed.hasPrefix("```") || trimmed.hasPrefix("~~~") {
                if let open = openFence {
                    // Closing fence
                    context.fencedCodeBlocks.append((
                        start: open.index,
                        end: i,
                        language: open.language
                    ))
                    openFence = nil
                } else {
                    // Opening fence - extract language
                    let fenceChars = trimmed.hasPrefix("```") ? "```" : "~~~"
                    let afterFence = String(trimmed.dropFirst(3))
                        .trimmingCharacters(in: .whitespaces)
                    let language = afterFence.isEmpty ? nil : afterFence
                    openFence = (index: i, language: language)
                }
            }
        }

        // Handle unclosed fence (extends to end of document)
        if let open = openFence {
            context.fencedCodeBlocks.append((
                start: open.index,
                end: paragraphs.count - 1,
                language: open.language
            ))
        }

        return context
    }

    /// Incremental update after an edit.
    /// Re-scans from affected paragraph to next stable point.
    func update(
        context: inout BlockContext,
        afterEditAt paragraphIndex: Int,
        paragraphs: [String]
    ) {
        // Remove blocks that start at or after the edit point
        context.fencedCodeBlocks.removeAll { block in
            block.start >= paragraphIndex || block.end >= paragraphIndex
        }

        // Re-scan from the edit point
        var openFence: (index: Int, language: String?)? = nil

        // Check if we're resuming inside an existing block
        for block in context.fencedCodeBlocks {
            if paragraphIndex > block.start && paragraphIndex <= block.end {
                // Edit is inside this block - remove it and rescan from its start
                context.fencedCodeBlocks.removeAll { $0.start == block.start }
                openFence = nil
                break
            }
        }

        let startIndex = context.fencedCodeBlocks.last.map { $0.end + 1 } ?? 0
        let scanStart = max(startIndex, paragraphIndex > 0 ? paragraphIndex - 1 : 0)

        for i in scanStart..<paragraphs.count {
            let text = paragraphs[i]
            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)

            if trimmed.hasPrefix("```") || trimmed.hasPrefix("~~~") {
                if let open = openFence {
                    context.fencedCodeBlocks.append((
                        start: open.index,
                        end: i,
                        language: open.language
                    ))
                    openFence = nil
                } else {
                    let afterFence = String(trimmed.dropFirst(3))
                        .trimmingCharacters(in: .whitespaces)
                    openFence = (index: i, language: afterFence.isEmpty ? nil : afterFence)
                }
            }
        }

        // Handle unclosed fence
        if let open = openFence {
            context.fencedCodeBlocks.append((
                start: open.index,
                end: paragraphs.count - 1,
                language: open.language
            ))
        }

        // Sort by start index
        context.fencedCodeBlocks.sort { $0.start < $1.start }
    }
}
```

**Step 6: Add scanner tests**

```swift
// Add to BlockContextTests.swift:

func testScannerFindsCodeBlock() {
    let paragraphs = [
        "Normal text",
        "```swift",
        "let x = 1",
        "```",
        "More text"
    ]

    let scanner = BlockContextScanner()
    let context = scanner.scan(paragraphs: paragraphs)

    XCTAssertEqual(context.fencedCodeBlocks.count, 1)
    XCTAssertEqual(context.fencedCodeBlocks[0].start, 1)
    XCTAssertEqual(context.fencedCodeBlocks[0].end, 3)
    XCTAssertEqual(context.fencedCodeBlocks[0].language, "swift")
}

func testScannerHandlesUnclosedBlock() {
    let paragraphs = [
        "```python",
        "code here",
        "more code"
    ]

    let scanner = BlockContextScanner()
    let context = scanner.scan(paragraphs: paragraphs)

    XCTAssertEqual(context.fencedCodeBlocks.count, 1)
    XCTAssertEqual(context.fencedCodeBlocks[0].start, 0)
    XCTAssertEqual(context.fencedCodeBlocks[0].end, 2)  // Extends to end
}

func testScannerFindsMultipleBlocks() {
    let paragraphs = [
        "```",
        "block 1",
        "```",
        "normal",
        "```",
        "block 2",
        "```"
    ]

    let scanner = BlockContextScanner()
    let context = scanner.scan(paragraphs: paragraphs)

    XCTAssertEqual(context.fencedCodeBlocks.count, 2)
}
```

**Step 7: Run all tests**

Run: `swift test --filter BlockContextTests`
Expected: All tests pass

**Step 8: Commit**

```bash
git add Sources/MarkdownEditor/Parser/BlockContext.swift
git add Sources/MarkdownEditor/Parser/BlockContextScanner.swift
git add Tests/MarkdownEditorTests/Parser/BlockContextTests.swift
git commit -m "feat(parser): add BlockContext and BlockContextScanner for fenced code blocks"
```

---

## Task 6: Integration and Final Tests

**Files:**
- Modify: `Sources/MarkdownEditor/Parser/MarkdownParser.swift`
- Create: `Tests/MarkdownEditorTests/Parser/IntegrationTests.swift`

**Step 1: Add integration tests**

```swift
import XCTest
@testable import MarkdownEditor

final class ParserIntegrationTests: XCTestCase {

    let parser = MarkdownParser()

    func testComplexParagraph() {
        let text = "# Heading with **bold** and *italic*"
        let tokens = parser.parse(text)

        // Should have heading, bold, and italic
        let hasHeading = tokens.contains { if case .heading = $0.element { return true }; return false }
        let hasBold = tokens.contains { if case .bold = $0.element { return true }; return false }
        let hasItalic = tokens.contains { if case .italic = $0.element { return true }; return false }

        XCTAssertTrue(hasHeading)
        XCTAssertTrue(hasBold)
        XCTAssertTrue(hasItalic)
    }

    func testLinkWithEmphasis() {
        let text = "Check [**bold link**](url)"
        let tokens = parser.parse(text)

        let hasLink = tokens.contains { if case .link = $0.element { return true }; return false }
        XCTAssertTrue(hasLink)
    }

    func testPlainText() {
        let text = "Just plain text, nothing special."
        let tokens = parser.parse(text)

        // Should return empty (no special formatting)
        XCTAssertEqual(tokens.count, 0)
    }

    func testEmptyString() {
        let tokens = parser.parse("")
        XCTAssertEqual(tokens.count, 0)
    }
}
```

**Step 2: Run all parser tests**

Run: `swift test`
Expected: All tests pass

**Step 3: Final commit**

```bash
git add Tests/MarkdownEditorTests/Parser/IntegrationTests.swift
git commit -m "test(parser): add integration tests

Parser module complete:
- Headings (1-6)
- Blockquotes
- Ordered and unordered lists
- Horizontal rules
- Bold, italic, bold+italic
- Inline code
- Links
- Block context for fenced code blocks"
```

---

## Integration with Other Modules

### Connecting to Core Rendering

In `PaneController` or wherever rendering is configured:

```swift
let parser = MarkdownParser()
paneController.setTokenProvider(parser)
```

### Connecting Block Context to DocumentModel

DocumentModel should use BlockContextScanner:

```swift
class DocumentModel {
    private(set) var blockContext: BlockContext = BlockContext()
    private let blockScanner = BlockContextScanner()

    func rebuildBlockContext() {
        var paragraphs: [String] = []
        for i in 0..<paragraphCount {
            if let text = paragraph(at: i) {
                paragraphs.append(text)
            }
        }
        blockContext = blockScanner.scan(paragraphs: paragraphs)
    }
}
```

---

## What This Module Delivers

| Component | Purpose |
|-----------|---------|
| `MarkdownParser` | Converts text → tokens, implements `TokenProviding` |
| `BlockContext` | Tracks fenced code block boundaries |
| `BlockContextScanner` | Detects multi-paragraph constructs |
| Tests | Comprehensive coverage for all element types |

The parser is pure and stateless. Block context for multi-paragraph constructs comes from DocumentModel, which uses BlockContextScanner.
